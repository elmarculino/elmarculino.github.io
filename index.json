[{"content":"","date":"12 October 2022","permalink":"/tags/dynamodb/","section":"Tags","summary":"","title":"dynamodb"},{"content":"","date":"12 October 2022","permalink":"/tags/etl/","section":"Tags","summary":"","title":"etl"},{"content":"Um tempo atrás criei uma aplicação web para gerenciamento de contas a pagar e a receber utilizando a infraestrutura da AWS e o Amplify. Ao se criar uma API GraphQL utilizando o Amplify CLI, toda a infraestrutura necessária é criada, incluindo funções Lambda e a base de dados DynamoDB. É tudo muito lindo, mas essa praticidade tem um custo, e não poder executar consultas SQL diretamente nos dados dificulta bastante a análise de dados.\nPara solucionar esse problema e cruzar os dados de contas a pagar com os de vendas, que são vem de um sistema com banco de dados Microsoft SQL, a solução mais fácil foi extrair as tabelas do DynamoDB e salvá-los em uma base Postgres (Ou qualquer banco de dados relacional que você preferir). Para isso foram utilizados os pacotes abaixo:\nImportação dos pacotes necessários # import boto3 import pandas as pd from sqlalchemy import create_engine Criação dos objetos utilizados na extração # engine = create_engine(\u0026#39;postgresql://nome_usuario:senha@endereco_banco:5432/nome_base\u0026#39;) client = boto3.client(\u0026#39;dynamodb\u0026#39;) dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;, region_name=\u0026#34;us-east-1\u0026#34;) # Listar tabelas client.list_tables() Realização do leitura completa da tabela # Para esse passo foi utilizada uma função que executa o full scan da tabela. Como cada consulta tem um limite de registros retornados, é utilizada a chave \u0026lsquo;LastEvaluatedKey\u0026rsquo;, retornada a cada consulta, para solicitar do próximo batch em um loop.\ndef table_scan(table): response = table.scan() data = response[\u0026#39;Items\u0026#39;] while \u0026#39;LastEvaluatedKey\u0026#39; in response: response = table.scan(ExclusiveStartKey=response[\u0026#39;LastEvaluatedKey\u0026#39;]) data.extend(response[\u0026#39;Items\u0026#39;]) return data table = dynamodb.Table(\u0026#39;parcelas-xxxxstringaleatoriaxxxxx-prod\u0026#39;) parcelas = table_scan(table) Criação do dataframe, tratamento e gravação dos dados # Nessa etapa é criado um dataframe Pandas para o tratamento inicial dos dados e a utilizado o método \u0026rsquo;to_sql\u0026rsquo;, que utiliza a engine do sqlalchemy criada anteriormente, para a gravação dos dados do DynamoDB na tabela SQL.\n# Cria um dataframe pandas com os dados da tabela df = pd.DataFrame(contas) # Converte os dados da colunas para o tipo desejado df = df.astype({ \u0026#39;valor\u0026#39;:\u0026#39;float\u0026#39;, \u0026#39;numeroParcela\u0026#39;:\u0026#39;int\u0026#39;, \u0026#39;quantidadeParcelas\u0026#39;:\u0026#39;int\u0026#39; }) # Remove colunas df.drop(labels=\u0026#39;__typename\u0026#39;, axis=1, inplace=True, errors=\u0026#39;raise\u0026#39;) # Grava dataframe no banco de dados df.to_sql(\u0026#39;parcelas\u0026#39;, con=engine, if_exists=\u0026#39;replace\u0026#39;, index=False, schema=\u0026#39;contas\u0026#39;) É isso, com os dados salvos em um banco de dados relacional é possível agora realizar consultas SQL e/ou utilizar o DBT para criar toda sorte de views e tabelas automaticamente para facilitar a análise de dados e a criação de dashboards.\n","date":"12 October 2022","permalink":"/posts/extracao-dados-dynamodb-postgres-mysql/","section":"Posts","summary":"Um tempo atrás criei uma aplicação web para gerenciamento de contas a pagar e a receber utilizando a infraestrutura da AWS e o Amplify. Ao se criar uma API GraphQL utilizando o Amplify CLI, toda a infraestrutura necessária é criada, incluindo funções Lambda e a base de dados DynamoDB.","title":"Extração de Dados do Amazon DynamoDB para Postgres/MySQL"},{"content":"","date":"12 October 2022","permalink":"/","section":"Marco Ribeiro","summary":"","title":"Marco Ribeiro"},{"content":"","date":"12 October 2022","permalink":"/tags/mysql/","section":"Tags","summary":"","title":"mysql"},{"content":"","date":"12 October 2022","permalink":"/tags/postgres/","section":"Tags","summary":"","title":"postgres"},{"content":"","date":"12 October 2022","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"","date":"12 October 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"6 October 2022","permalink":"/tags/azure/","section":"Tags","summary":"","title":"azure"},{"content":"","date":"6 October 2022","permalink":"/tags/bash/","section":"Tags","summary":"","title":"bash"},{"content":"Cut string # my_filename=\u0026#34;interesting-text-file.txt\u0026#34; echo ${my_filename:0:21} echo ${my_filename%.*} complicated_filename=\u0026#34;hello-world.tar.gz\u0026#34; echo ${complicated_filename%%.*} echo ${my_filename/.*/} sed \u0026#39;s/[.].*//\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; cut -f1 -d\u0026#34;.\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; ~/execute_string.sh # your_command_string=\u0026#34;...\u0026#34; output=$(eval \u0026#34;$your_command_string\u0026#34;) echo \u0026#34;$output\u0026#34; ~/random.sh # echo $(( $RANDOM % 50 + 1 )) numero=${RANDOM:0:2} ~/return_values.sh # my_function () { func_result=\u0026#34;some result\u0026#34; } my_function echo $func_result ~/return_values.sh # my_function () { local func_result=\u0026#34;some result\u0026#34; echo \u0026#34;$func_result\u0026#34; } func_result=\u0026#34;$(my_function)\u0026#34; echo $func_result ~/passing_arguments.sh # greeting () { echo \u0026#34;Hello $1\u0026#34; } greeting \u0026#34;Joe\u0026#34; if, elif, else: # echo -n \u0026#34;Enter a number: \u0026#34; read VAR if [[ $VAR -gt 10 ]] then echo \u0026#34;The variable is greater than 10.\u0026#34; elif [[ $VAR -eq 10 ]] then echo \u0026#34;The variable is equal to 10.\u0026#34; else echo \u0026#34;The variable is less than 10.\u0026#34; fi Multiple conditions # if [[ $VAR1 -ge $VAR2 ]] \u0026amp;\u0026amp; [[ $VAR1 -ge $VAR3 ]] then echo \u0026#34;$VAR1 is the largest number.\u0026#34; elif [[ $VAR2 -ge $VAR1 ]] \u0026amp;\u0026amp; [[ $VAR2 -ge $VAR3 ]] then echo \u0026#34;$VAR2 is the largest number.\u0026#34; else echo \u0026#34;$VAR3 is the largest number.\u0026#34; fi Test Operators # -n VAR - True if the length of VAR is greater than zero. -z VAR - True if the VAR is empty. STRING1 = STRING2 - True if STRING1 and STRING2 are equal. STRING1 != STRING2 - True if STRING1 and STRING2 are not equal. INTEGER1 -eq INTEGER2 - True if INTEGER1 and INTEGER2 are equal. INTEGER1 -gt INTEGER2 - True if INTEGER1 is greater than INTEGER2. INTEGER1 -lt INTEGER2 - True if INTEGER1 is less than INTEGER2. INTEGER1 -ge INTEGER2 - True if INTEGER1 is equal or greater than INTEGER2. INTEGER1 -le INTEGER2 - True if INTEGER1 is equal or less than INTEGER2. ","date":"6 October 2022","permalink":"/snippets/bash-script-snippets/","section":"Snippets","summary":"Cut string # my_filename=\u0026#34;interesting-text-file.txt\u0026#34; echo ${my_filename:0:21} echo ${my_filename%.*} complicated_filename=\u0026#34;hello-world.tar.gz\u0026#34; echo ${complicated_filename%%.*} echo ${my_filename/.*/} sed \u0026#39;s/[.].*//\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; cut -f1 -d\u0026#34;.\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; ~/execute_string.sh # your_command_string=\u0026#34;...\u0026#34; output=$(eval \u0026#34;$your_command_string\u0026#34;) echo \u0026#34;$output\u0026#34; ~/random.sh # echo $(( $RANDOM % 50 + 1 )) numero=${RANDOM:0:2} ~/return_values.","title":"Bash Script Snippets"},{"content":"","date":"6 October 2022","permalink":"/tags/datafactory/","section":"Tags","summary":"","title":"datafactory"},{"content":"","date":"6 October 2022","permalink":"/tags/jq/","section":"Tags","summary":"","title":"jq"},{"content":"Nem tudo na vida de um engenheiro de dados são flores. As vezes é necessário fazer a \u0026ldquo;difícil\u0026rdquo; escolha entre usar força bruta ou passar horas alterando manualmente pipelines de dados em interfaces ‘clica e arrasta’. Para ilustrar o problema em questão, usaremos o caso do orquestrador de pipelines de dados Azure Data Factory da Microsoft. Por trás da interface gráfica, os pipelines, linked services e data sources são salvos em arquivos JSON que se referenciam e que posteriormente são processados para a geração dos ARM Templates e implantação nos workspaces.\nPara esse trabalho os principais comandos utilizados foram sed para a substituição de strings e jq para a leitura da estrutura dos arquivos JSON diretamente no terminal. Os arquivos do Data Factory foram clonados do repositório GIT do projeto e seguintes comandos foram utilizados para a realização das alterações necessárias.\nRenomear artefatos no arquivo JSON # Para renomear um pipeline ou linked service, não basta alterar o nome do arquivo ou o seu conteúdo, é necessário fazer os dois. Por isso, para alterar o nome de diversos artefatos para, por exemplo, remover a referencia ao ambiente do nome do objeto e não ter problemas quanto o pipeline de DevOps fizer o deploy do ARM Template em um ambiente diferente.\n# Remover sufixo referente ao ambiente dos pipelines sed -i \u0026#39;s/_prd//g\u0026#39; *.json # Renomear arquivos json das pipelines de acordo com novo nome for i in *.json; do new=$(jq -r \u0026#39;.name\u0026#39; \u0026#34;${i}\u0026#34;).json \u0026amp;\u0026amp; mv \u0026#34;$i\u0026#34; \u0026#34;$new\u0026#34;; done Alterar Path dos notebooks de PRD para novo path genérico # sed -i \u0026#39;s/\u0026#34;name\u0026#34;: \u0026#34;ProjetoX_PRD/\u0026#34;name\u0026#34;: \u0026#34;ProjetoX/g\u0026#39; *.json Alterar linked services com referencia ao integration runtime # sed -i \u0026#39;s/\u0026#34;referenceName\u0026#34;: \u0026#34;IR-XPTO-PRD\u0026#34;/\u0026#34;referenceName\u0026#34;: \u0026#34;ir-xpto\u0026#34;/g\u0026#39; *.json Alterar Path dos notebooks do Databricks para nova estrutura # Suponhamos que os notebooks do databricks foram desenvolvidos nas pastas do workspace e posteriormente foi feita a integração de um repositório git. O path necessariamente terá que ser alterado em todos os pipelines que utilizem a atividade do databricks e isso pode ser feito em uma linha utilizando o comando sed.\nsed -i \u0026#39;s/\u0026#34;notebookPath\u0026#34;: \u0026#34;\\/path_antigo\\/pasta_qualquer/\u0026#34;notebookPath\u0026#34;: \u0026#34;/g\u0026#39; *.json Consolidar diversos linked services em um # linked_services=(\u0026#34;lks_abc1\u0026#34; \u0026#34;lks_abc_prd\u0026#34; \u0026#34;lks_abc_test\u0026#34; \u0026#34;lks_abc_generic\u0026#34;) for s in \u0026#34;${linked_services[@]}\u0026#34;; do sed -i \u0026#39;s/\u0026#34;referenceName\u0026#34;: \u0026#34;\u0026#39;$s\u0026#39;\u0026#34;/\u0026#34;referenceName\u0026#34;: \u0026#34;lks_abc\u0026#34;/g\u0026#39; *.json done Remover datasets sem objetos vinculados # datasets=$(ls dataset | sed \u0026#39;s/\\(.*\\)\\..*/\\1/\u0026#39;) for f in $datasets; do pipelines=$(grep -l -R \u0026#39;\u0026#34;referenceName\u0026#34;: \u0026#34;\u0026#39;$f\u0026#39;\u0026#34;,\u0026#39; pipeline/* | sed \u0026#39;s/.*\\///;s/\\(.*\\)\\..*/\\1/\u0026#39;) lenght=$(echo -n \u0026#34;$pipelines\u0026#34; | grep -c \u0026#39;^\u0026#39;) if [ $lenght -eq 0 ]; then rm datafactory/dataset/$f.json fi done ","date":"6 October 2022","permalink":"/posts/refatoracao-data-factory-bash/","section":"Posts","summary":"Nem tudo na vida de um engenheiro de dados são flores. As vezes é necessário fazer a \u0026ldquo;difícil\u0026rdquo; escolha entre usar força bruta ou passar horas alterando manualmente pipelines de dados em interfaces ‘clica e arrasta’.","title":"Refatoração Azure Data Factory com Bash Script"},{"content":"","date":"6 October 2022","permalink":"/tags/script/","section":"Tags","summary":"","title":"script"},{"content":"","date":"6 October 2022","permalink":"/tags/sed/","section":"Tags","summary":"","title":"sed"},{"content":"","date":"6 October 2022","permalink":"/snippets/","section":"Snippets","summary":"","title":"Snippets"},{"content":"","date":"13 June 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" broot # br -dp # replace \u0026#39;ls\u0026#39;, display dates and permissions br -s # to identify what is taking disk space :gf # display git statuses fasd # alias a=\u0026#39;fasd -a\u0026#39; # any alias s=\u0026#39;fasd -si\u0026#39; # show / search / select alias d=\u0026#39;fasd -d\u0026#39; # directory alias f=\u0026#39;fasd -f\u0026#39; # file alias sd=\u0026#39;fasd -sid\u0026#39; # interactive directory selection alias sf=\u0026#39;fasd -sif\u0026#39; # interactive file selection alias z=\u0026#39;fasd_cd -d\u0026#39; # cd, same functionality as j in autojump alias zz=\u0026#39;fasd_cd -d -i\u0026#39; # cd with interactive selection alias v=\u0026#39;f -e vim\u0026#39; # quick opening files with vim fd # # Convert all jpg files to png files: fd -e jpg -x convert {} {.}.png fd passwd /etc # Searching \u0026#39;passwd\u0026#39; in the /etc folder fd -e md # Searching for a particular file extension fd -H pre-commit # Include hidden files fd -E \u0026#39;*.bak\u0026#39; # Excluding specific files or directories fzf # vim **\u0026lt;TAB\u0026gt; # Select multiple items with TAB key fd --type f | fzf # Feed the output of fd into fzf # Setting fd as the default source for fzf export FZF_DEFAULT_COMMAND=\u0026#39;fd --type f\u0026#39; ripgrep # rg \u0026#39;fast\\w+\u0026#39; README.md ","date":"10 February 2020","permalink":"/posts/awesome-command-line-tools/","section":"Posts","summary":"broot # br -dp # replace \u0026#39;ls\u0026#39;, display dates and permissions br -s # to identify what is taking disk space :gf # display git statuses fasd # alias a=\u0026#39;fasd -a\u0026#39; # any alias s=\u0026#39;fasd -si\u0026#39; # show / search / select alias d=\u0026#39;fasd -d\u0026#39; # directory alias f=\u0026#39;fasd -f\u0026#39; # file alias sd=\u0026#39;fasd -sid\u0026#39; # interactive directory selection alias sf=\u0026#39;fasd -sif\u0026#39; # interactive file selection alias z=\u0026#39;fasd_cd -d\u0026#39; # cd, same functionality as j in autojump alias zz=\u0026#39;fasd_cd -d -i\u0026#39; # cd with interactive selection alias v=\u0026#39;f -e vim\u0026#39; # quick opening files with vim fd # # Convert all jpg files to png files: fd -e jpg -x convert {} {.","title":"Best command line tools"},{"content":"","date":"10 February 2020","permalink":"/tags/fd/","section":"Tags","summary":"","title":"fd"},{"content":"","date":"10 February 2020","permalink":"/tags/fzf/","section":"Tags","summary":"","title":"fzf"},{"content":"","date":"10 February 2020","permalink":"/tags/ripgrep/","section":"Tags","summary":"","title":"ripgrep"},{"content":"","date":"10 February 2020","permalink":"/tags/vim/","section":"Tags","summary":"","title":"vim"},{"content":"Use Vim without your own .vimrc is not an easy task. Trainning to a certification test I was forced to use an virtual machine without my customizations. So, I had to find an minimal setup that would make the default Vim usable for me. That one-liner is what I type every time I open Vim without my config:\nset nocp rnu ai et sw=4 ts=4 bs=2 To start Vim without loading your configs:\nvim -u NONE Each config option explained:\nset nocp # nocompatible set nu # number set rnu # relativenumber set et # expandtab set ai # autoindent \u0026#34;automatic indentation set ts=4 # tabstop set sw=4 # shiftwidth set bs=2 # backspace \u0026#34;allows the backspace to work ","date":"10 February 2020","permalink":"/posts/vim-minimal-setup/","section":"Posts","summary":"Use Vim without your own .vimrc is not an easy task. Trainning to a certification test I was forced to use an virtual machine without my customizations. So, I had to find an minimal setup that would make the default Vim usable for me.","title":"Vim Personal Minimal Setup"},{"content":"Durante o desenvolvimento de uma aplicação utilizando machine learning para, por exemplo, classificar imagens, não é necessário que se desenvolva uma Convolutional Neural Network do zero. Isso na verdade seria uma enorme perda de tempo e recursos computacionais, além de exigir do desenvolvedor expertise em tópicos como a inicialização dos pesos na rede neural. A técnica mais utilizada hoje em dia para desenvolver esse tipo de aplicação é a utilização de transfer learning, a modificação de redes neurais treinadas para outros fins que são alteradas e passam por treinamento fino para executar outras atividades.\nUm exemplo comum é a utilização da DCNN ImageNet, uma rede neural com 60 milhões de parametros e 500 mil neurons treinada com mais de 1,3 milhão de imagens para a classificação de 1000 diferentes classes. A idea, nesse caso, é remover a última camada da rede, treinada para a classificação das 1000 classes, e substituir por outra que será treinada com um novo dataset para um novo objetivo.\nRemover usando o index\nresnet18 = models.resnet18() cnn_modules = list(resnet18.children())[:-1] cnn = nn.Sequential(*cnn_modules) Remover definindo ponto de corte\nresnet18 = models.resnet18() cut = next(i for i,o in enumerate(resnet18.children()) if isinstance(o,nn.AdaptiveAvgPool2d)) m_cut = resnet18[:cut] cnn = nn.Sequential(m_cut, AdaptiveConcatPool2d()) ","date":"14 January 2020","permalink":"/posts/substituir-ultima-camada-rede-neural-pytorch/","section":"Posts","summary":"Durante o desenvolvimento de uma aplicação utilizando machine learning para, por exemplo, classificar imagens, não é necessário que se desenvolva uma Convolutional Neural Network do zero. Isso na verdade seria uma enorme perda de tempo e recursos computacionais, além de exigir do desenvolvedor expertise em tópicos como a inicialização dos pesos na rede neural.","title":"Como Substituir a Última Camada de Rede Neural no PyTorch"},{"content":"","date":"14 January 2020","permalink":"/tags/pytorch/","section":"Tags","summary":"","title":"pytorch"},{"content":"","date":"10 January 2020","permalink":"/tags/emacs/","section":"Tags","summary":"","title":"emacs"},{"content":"Emacs Key Biddings # C-x reserved for Emacs native essential keybindings: buffer, window, frame, file, directory, etc…\nC-c reserved for user and major mode:\nC-c letter reserved for user. \u0026lt;F5\u0026gt;-\u0026lt;F9\u0026gt; reserved for user. C-c C-letter reserved for major mode. Don\u0026rsquo;t rebind C-g, C-h and ESC.\nExamples:\nC-x C-f\tfind-file: first prompts for a filename and then loads that file into a editor buffer of the same name C-x C-s\tsave-buffer: saves the buffer into the associated filename C-x C-w\twrite-named-file: prompts for a new filename and writes the buffer into it C-x b switch-to-buffer: display a different buffer on the screen C-x o other-window: move the cursor to the other window C-x C-b\tlist-buffers: lists those buffers currently loaded into emacs C-g to cancel any action you have started. Doom Emacs Key Bindings # SPC h b b Abre lista de atalhos de teclado M-d Cria multiplos cursores SPC h v Able lista de variaveis evil-snipe navigation # f or t ; - next , - previous\navy navigation # g s SPC - Começa a busca no buffer pelo avy\nevil-lion # glip= # gl - left align operator, ip - text paragraph, = separator gLip, # gL - right align operator, \u0026lsquo;,\u0026rsquo; separator\nOrg Mode # Org Mode Key Bindings C-M-i (complete-symbol) complete word at point C-c \u0026rsquo; for editing the current code block.\nsetting tags # C-c C-q (org-set-tags-command) enter new tags for the current headline.\nhandling links # C-c C-l (org-insert-link) insert a link.\nproperty syntax # C-c C-x p (org-set-property) set a property. C-c C-c s (org-set-property) set a property in the current entry. C-c C-c d (org-delete-property) remove a property from the current entry.\nstructure editing # C-c C-x C-w (org-cut-subtree) kill subtree. C-c C-x M-w (org-copy-subtree) copy subtree to kill ring. C-c C-x C-y (org-paste-subtree) yank subtree from kill ring. C-c C-x c (org-clone-subtree-with-time-shift) Clone a subtree by making a number of sibling copies of it. C-c C-w (org-refile) Refile entry or region to a different location.\ndoom emacs links # doom emacs workflows emacs doom for newbies ox-hugo # C-c C-x p Set property SPC m o Set property C-c C-e H H Export C-c C-e H A Export all Exemplo all-posts Org Mode Code Snippets # Para adicionar um Code Snippet digite \u0026lt;s + TAB para autocompletar.\nPara que o print() funcione em códigos python, adicionar o argumento no header \u0026lsquo;:results output\u0026rsquo;.\nExemplo Closure Javascript # const counter = () =\u0026gt; { let n = 0; return { count: () =\u0026gt; n++, reset: () =\u0026gt; { n = 0; } }; } const c = counter(), d = counter(); // Create two counters console.log(c.count()) // =\u0026gt; 0 console.log(d.count()) // =\u0026gt; 0: they count independently console.log(c.reset()) // reset() and count() methods share state console.log(c.count()) // =\u0026gt; 0: because we reset c console.log(d.count()) // =\u0026gt; 1: d was not reset Exemplo Python # def hamming(a, b): return len([i for i in filter(lambda x: x[0] != x[1], zip(a, b))]) a = \u0026#34;Teste string 1\u0026#34; b = \u0026#34;Teste string 2\u0026#34; result = hamming(a, b) print(result) a = [1, 2, 3] b = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(list(zip(a, b))) ","date":"10 January 2020","permalink":"/posts/emacs-key-bindings/","section":"Posts","summary":"Emacs Key Biddings # C-x reserved for Emacs native essential keybindings: buffer, window, frame, file, directory, etc…\nC-c reserved for user and major mode:\nC-c letter reserved for user. \u0026lt;F5\u0026gt;-\u0026lt;F9\u0026gt; reserved for user.","title":"Emacs Key Bindings"},{"content":"","date":"10 January 2020","permalink":"/tags/shortcuts/","section":"Tags","summary":"","title":"shortcuts"},{"content":"Vim Command Language and examples of how to get things done.\nVerbs # v : visual c : change d : delete y : yank/copy Modifiers # i : inside a : around t : till..finds a character f : find..like till except including the char / : search..find a string/regex Text Objects # w : word s : sentence p : paragraph b : block/parentheses, t : tag, works for html/xml VIM Shortcuts # Navigation # zz : current line to top zt : current line to middle zb : current line to bottom C+y : scroll up one line C+e : scroll down one line C+u : scroll up half-page C+d : scroll down half-page C+b : scroll up full-page C+f : scroll down full-page H : cursor to the top of the screen M : cursor to the middle of the screen L : cursor to the botton of the screen e : go to the end of the current word. E : go to the end of the current WORD. b : go to the previous (before) word. B : go to the previous (before) WORD. w : go to the next word. W : go to the next WORD. g; : go to the last editing place. 0 : beginning of line ^ : first char of line $ : end of line { : Go to the beginning of the current paragraph. } : Go to the end of the current paragraph. /i : Search to the next occurrence of it. ?i : Search to the previous occurrence of it. – : Go to the next occurrence of the current word under the cursor. # : Go to the previous occurrence of the current word under the cursor. % : Go to the matching braces, or parenthesis inside code. Folding # zf#j : creates a fold from the cursor down # lines. zf/string : creates a fold from the cursor to string . za : opens/closes all folds zj : moves the cursor to the next fold zk : moves the cursor to the previous fold zc : closes a fold at the cursor zo : opens a fold at the cursor zO : opens all folds at the cursor zm : increases the foldlevel by one zM : closes all open folds zr : decreases the foldlevel by one zR : decreases the foldlevel to zero — all folds will be open zd : deletes the fold at the cursor zE : deletes all folds [z : move to start of open fold ]z : move to end of open fold Jump # C+o : go to origin Marks # m + letter : create mark \u0026#39; + letter : go to mark Yank / Paste # :reg : list registers \u0026#34;1p : paste previous deletes/yanks yiw : Yank inner word (copy word under cursor, say \u0026#34;first\u0026#34;). viwp : Select \u0026#34;second\u0026#34;, then replace it with \u0026#34;first\u0026#34;. yi( : equivalent to yib, yanks the contents inside parenthesis. yi{ : equivalent to yiB, yanks the contents inside braces. Insert Multiple # 80i/\u0026lt;ESC\u0026gt; : insert 80 \u0026#39;/\u0026#39; in a line 20Otest\u0026lt;ESC\u0026gt; : insert 20 lines of \u0026#39;test\u0026#39; Change Multiple # * : to select all words cgn+Esc : to change de word . : to change the next Esc : to enter \u0026#39;command mode\u0026#39; C-v : to enter visual block mode and select the columns of text. M-i : to enter insert mode and type the text you want to insert. Esc : wait 1 second and the inserted text will appear on every line. :%s/foo/bar/g :s/foo/bar/g :%s/foo/bar/gc Selection # ggVG : select all Letter Case # ~ : changes the case of current character guu : change current line from upper to lower. gUU : change current LINE from lower to upper. guw : change to end of current WORD from upper to lower. guaw : change all of current WORD to lower. gUw : change to end of current WORD from lower to upper. gUaw : change all of current WORD to upper. g~~ : invert case to entire line guG : change to lowercase until the end of document. Split # :sp : horizontal split :vs : vertical split C+W S : horizontal splitting C+W v : vertical splitting C+W q : close split C+W C+W : switch between windows C+W J K, H, L : switch to adjacent window ( up, down, left, right ) C-w t C-w K : change two vertically split windows to horizonally split C-w t C-w H : Horizontally to vertically C-w t : makes the first (topleft) window current C-w K : moves the current window to full-width at the very top C-w H : moves the current window to full-height at far left Tags # Spaces # :%le\t: Remove left spaces in the entire file Macros # qd : start recording to register d q : stop recording @d : execute your macro @@ : execute your macro again VIM Plugins # Prettier # L-p : Manually trigger Prettier FZF # C-t : tab split C-x : split C-v : vsplit Surround # cs\u0026#34;\u0026#39; : replace \u0026#34; with \u0026#39; cst\u0026#34; : replace tag with \u0026#34; ds\u0026#34; : to remove \u0026#34; delimiters entirely. ysiw] : add brackets arround a word. cs]{ : add some space (use } instead of { for no space): cs]{ yssb : wrap the entire line in parentheses with yssb or yss). Commenter # L-cc : Comment out the current line or text selected in visual mode. L-cn : Same as cc but forces nesting. L-c\u0026lt;space\u0026gt; : Toggles the comment state of the selected line(s). L-cm : Comments the given lines using only one set of multipart delimiters. L-ci : Toggles the comment state of the selected line(s) individually. L-cs : Comments out the selected lines with a pretty block formatted layout. L-cy : Same as cc except that the commented line(s) are yanked first. L-c$ : Comments the current line from the cursor to the end of line. L-cA : Adds comment delimiters to the end of line and goes into insert mode between them. L-ca : Switches to the alternative set of delimiters. L-cl : Delimiters are aligned down the left side (\u0026lt;leader\u0026gt;cl) or both sides (\u0026lt;leader\u0026gt;cb). L-cu : Uncomments the selected line(s). vim-easy-align # vipga= : visual-select inner paragraph, Start EasyAlign (ga), Align around = gaip= : Start EasyAlign for inner paragraph, Align around = = : Around the 1st occurrences 2= : Around the 2nd occurrences *= : Around all occurrences **= : Left/Right alternating alignment around all occurrences \u0026lt;Enter\u0026gt; : Switching between left/right/center alignment modes splitjoin.vim # gS : to split a one-liner into multiple lines gJ : to join a block into a single-line statement. ","date":"10 January 2020","permalink":"/posts/vim-key-bindings/","section":"Posts","summary":"Vim Command Language and examples of how to get things done.\nVerbs # v : visual c : change d : delete y : yank/copy Modifiers # i : inside a : around t : till.","title":"Vim Key Bindings"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub .\n","date":"28 February 2019","permalink":"/about/","section":"Marco Ribeiro","summary":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Para treinar um modelo de machine learning que realize o reconhecimento de caracteres, OCR, é necessário uma grande quantidade de imagens de placas. Daria um trabalho enorme conseguir milhares de imagens de carros com as placas visíveis, recortar as placas das imagens e anotar as imagens com os textos dos números das placas. Minha solução para obter essas milhares de imagens foi simplesmente gerá-las.\nComo o Brasil está adotando um novo padrão de placas é necessário utilizar dois templates. O primeiro utiliza imagens de placas antigas e insere os caracteres no padrão ABC-1234, o segundo com imagens de placas novas, insere os caracteres com a nova fonte no padrão ABC1D23 com 4 letras e 3 números.\nPara gerar os números de placas antigas foram utilizadas as seguintes funções:\nfrom random import randrange letters = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; letters_len = len(letters) def get_idx(l): return randrange(l) def plate_number_generator(): plate_number = \u0026#39;\u0026#39; for i in range(3): plate_number += letters[get_idx(letters_len)] plate_number += format(randrange(9999), \u0026#39;04d\u0026#39;) return plate_number def new_plate_number_generator(): plate_number = \u0026#39;\u0026#39; for i in range(3): plate_number += letters[get_idx(letters_len)] plate_number += format(randrange(9), \u0026#39;01d\u0026#39;) plate_number += letters[get_idx(letters_len)] plate_number += format(randrange(99), \u0026#39;02d\u0026#39;) return plate_number plate = plate_number_generator() new_plate = new_plate_number_generator() print(f\u0026#39;Placa antiga: {plate}\u0026#39;) print(f\u0026#39;Placa nova: {new_plate}\u0026#39;) Para gerar as imagens das placas\n","date":"1 January 0001","permalink":"/posts/gerador-imagens-placas-carros/","section":"Posts","summary":"Para treinar um modelo de machine learning que realize o reconhecimento de caracteres, OCR, é necessário uma grande quantidade de imagens de placas. Daria um trabalho enorme conseguir milhares de imagens de carros com as placas visíveis, recortar as placas das imagens e anotar as imagens com os textos dos números das placas.","title":"Criando Um Gerador de Imagens de Placas de Carros"}]