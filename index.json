[{"content":"Cut string # my_filename=\u0026#34;interesting-text-file.txt\u0026#34; echo ${my_filename:0:21} echo ${my_filename%.*} complicated_filename=\u0026#34;hello-world.tar.gz\u0026#34; echo ${complicated_filename%%.*} echo ${my_filename/.*/} sed \u0026#39;s/[.].*//\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; cut -f1 -d\u0026#34;.\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; ~/execute_string.sh # your_command_string=\u0026#34;...\u0026#34; output=$(eval \u0026#34;$your_command_string\u0026#34;) echo \u0026#34;$output\u0026#34; ~/random.sh # echo $(( $RANDOM % 50 + 1 )) numero=${RANDOM:0:2} ~/return_values.sh # my_function () { func_result=\u0026#34;some result\u0026#34; } my_function echo $func_result ~/return_values.sh # my_function () { local func_result=\u0026#34;some result\u0026#34; echo \u0026#34;$func_result\u0026#34; } func_result=\u0026#34;$(my_function)\u0026#34; echo $func_result ~/passing_arguments.sh # greeting () { echo \u0026#34;Hello $1\u0026#34; } greeting \u0026#34;Joe\u0026#34; if, elif, else: # echo -n \u0026#34;Enter a number: \u0026#34; read VAR if [[ $VAR -gt 10 ]] then echo \u0026#34;The variable is greater than 10.\u0026#34; elif [[ $VAR -eq 10 ]] then echo \u0026#34;The variable is equal to 10.\u0026#34; else echo \u0026#34;The variable is less than 10.\u0026#34; fi Multiple conditions # if [[ $VAR1 -ge $VAR2 ]] \u0026amp;\u0026amp; [[ $VAR1 -ge $VAR3 ]] then echo \u0026#34;$VAR1 is the largest number.\u0026#34; elif [[ $VAR2 -ge $VAR1 ]] \u0026amp;\u0026amp; [[ $VAR2 -ge $VAR3 ]] then echo \u0026#34;$VAR2 is the largest number.\u0026#34; else echo \u0026#34;$VAR3 is the largest number.\u0026#34; fi Test Operators # -n VAR - True if the length of VAR is greater than zero. -z VAR - True if the VAR is empty. STRING1 = STRING2 - True if STRING1 and STRING2 are equal. STRING1 != STRING2 - True if STRING1 and STRING2 are not equal. INTEGER1 -eq INTEGER2 - True if INTEGER1 and INTEGER2 are equal. INTEGER1 -gt INTEGER2 - True if INTEGER1 is greater than INTEGER2. INTEGER1 -lt INTEGER2 - True if INTEGER1 is less than INTEGER2. INTEGER1 -ge INTEGER2 - True if INTEGER1 is equal or greater than INTEGER2. INTEGER1 -le INTEGER2 - True if INTEGER1 is equal or less than INTEGER2. ","date":"6 October 2022","permalink":"/snippets/bash-script-snippets/","section":"Snippets","summary":"Cut string # my_filename=\u0026#34;interesting-text-file.txt\u0026#34; echo ${my_filename:0:21} echo ${my_filename%.*} complicated_filename=\u0026#34;hello-world.tar.gz\u0026#34; echo ${complicated_filename%%.*} echo ${my_filename/.*/} sed \u0026#39;s/[.].*//\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; cut -f1 -d\u0026#34;.\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#39;hello-world.tar.gz\u0026#39; ~/execute_string.sh # your_command_string=\u0026#34;...\u0026#34; output=$(eval \u0026#34;$your_command_string\u0026#34;) echo \u0026#34;$output\u0026#34; ~/random.sh # echo $(( $RANDOM % 50 + 1 )) numero=${RANDOM:0:2} ~/return_values.","title":"Bash Script Snippets"},{"content":"","date":"6 October 2022","permalink":"/","section":"Marco Ribeiro","summary":"","title":"Marco Ribeiro"},{"content":"Nem tudo na vida de um engenheiro de dados são flores. As vezes é necessário fazer a \u0026ldquo;difícil\u0026rdquo; escolha entre usar força bruta ou passar horas alterando manualmente pipelines de dados em interfaces ‘clica e arrasta’. Para ilustrar o problema em questão, usaremos o caso do orquestrador de pipelines de dados Azure Data Factory da Microsoft. Por trás interface gráfica todos os objetos dos pipelines são salvos em arquivos JSON\u0026hellip;.\nAlterar Path dos notebooks do Databricks para nova estrutura # Suponhamos que os notebooks do databricks foram desenvolvidos nas pastas do workspace e posteriormente foi feita a integração de um repositório git. O path necessariamente terá que ser alterado em todos os pipelines que utilizem a atividade do databricks e isso pode ser feito utilizando o comando sed.\nsed -i \u0026#39;s/\u0026#34;notebookPath\u0026#34;: \u0026#34;\\/path_antigo\\/pasta_qualquer/\u0026#34;notebookPath\u0026#34;: \u0026#34;/g\u0026#39; *.json ","date":"6 October 2022","permalink":"/posts/refatoracao-data-factory-bash/","section":"Posts","summary":"Nem tudo na vida de um engenheiro de dados são flores. As vezes é necessário fazer a \u0026ldquo;difícil\u0026rdquo; escolha entre usar força bruta ou passar horas alterando manualmente pipelines de dados em interfaces ‘clica e arrasta’.","title":"Refatoração Azure Data Factory com Bash Script"},{"content":"","date":"6 October 2022","permalink":"/snippets/","section":"Snippets","summary":"","title":"Snippets"},{"content":"","date":"13 June 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" broot # br -dp # replace \u0026#39;ls\u0026#39;, display dates and permissions br -s # to identify what is taking disk space :gf # display git statuses fasd # alias a=\u0026#39;fasd -a\u0026#39; # any alias s=\u0026#39;fasd -si\u0026#39; # show / search / select alias d=\u0026#39;fasd -d\u0026#39; # directory alias f=\u0026#39;fasd -f\u0026#39; # file alias sd=\u0026#39;fasd -sid\u0026#39; # interactive directory selection alias sf=\u0026#39;fasd -sif\u0026#39; # interactive file selection alias z=\u0026#39;fasd_cd -d\u0026#39; # cd, same functionality as j in autojump alias zz=\u0026#39;fasd_cd -d -i\u0026#39; # cd with interactive selection alias v=\u0026#39;f -e vim\u0026#39; # quick opening files with vim fd # # Convert all jpg files to png files: fd -e jpg -x convert {} {.}.png fd passwd /etc # Searching \u0026#39;passwd\u0026#39; in the /etc folder fd -e md # Searching for a particular file extension fd -H pre-commit # Include hidden files fd -E \u0026#39;*.bak\u0026#39; # Excluding specific files or directories fzf # vim **\u0026lt;TAB\u0026gt; # Select multiple items with TAB key fd --type f | fzf # Feed the output of fd into fzf # Setting fd as the default source for fzf export FZF_DEFAULT_COMMAND=\u0026#39;fd --type f\u0026#39; ripgrep # rg \u0026#39;fast\\w+\u0026#39; README.md ","date":"10 February 2020","permalink":"/posts/awesome-command-line-tools/","section":"Posts","summary":"broot # br -dp # replace \u0026#39;ls\u0026#39;, display dates and permissions br -s # to identify what is taking disk space :gf # display git statuses fasd # alias a=\u0026#39;fasd -a\u0026#39; # any alias s=\u0026#39;fasd -si\u0026#39; # show / search / select alias d=\u0026#39;fasd -d\u0026#39; # directory alias f=\u0026#39;fasd -f\u0026#39; # file alias sd=\u0026#39;fasd -sid\u0026#39; # interactive directory selection alias sf=\u0026#39;fasd -sif\u0026#39; # interactive file selection alias z=\u0026#39;fasd_cd -d\u0026#39; # cd, same functionality as j in autojump alias zz=\u0026#39;fasd_cd -d -i\u0026#39; # cd with interactive selection alias v=\u0026#39;f -e vim\u0026#39; # quick opening files with vim fd # # Convert all jpg files to png files: fd -e jpg -x convert {} {.","title":"Best command line tools"},{"content":"Use Vim without your own .vimrc is not an easy task. Tranning to a certification test I was forced to use an virtual machine without my customizations. So, I had to find an minimal setup that would make the default Vim usable for me. That one linner is what I type every time I open Vim without my config:\nset nocp rnu ai et sw=4 ts=4 bs=2 To start Vim without loading your configs:\nvim -u NONE Each config option explained:\nset nocp # nocompatible set nu # number set rnu # relativenumber set et # expandtab set ai # autoindent \u0026#34;automatic indentation set ts=4 # tabstop set sw=4 # shiftwidth set bs=2 # backspace \u0026#34;allows the backspace to work ","date":"10 February 2020","permalink":"/posts/vim-minimal-setup/","section":"Posts","summary":"Use Vim without your own .vimrc is not an easy task. Tranning to a certification test I was forced to use an virtual machine without my customizations. So, I had to find an minimal setup that would make the default Vim usable for me.","title":"Vim Personal Minimal Setup"},{"content":"Durante o desenvolvimento de uma aplicação utilizando machine learning para, por exemplo, classificar imagens, não é necessário que se desenvolva uma Convolutional Neural Network do zero. Isso na verdade seria uma enorme perda de tempo e recursos computacionais, além de exigir do desenvolvedor expertise em tópicos como a inicialização dos pesos na rede neural. A técnica mais utilizada hoje em dia para desenvolver esse tipo de aplicação é a utilização de transfer learning, a modificação de redes neurais treinadas para outros fins que são alteradas e passam por treinamento fino para executar outras atividades.\nUm exemplo comum é a utilização da DCNN ImageNet, uma rede neural com 60 milhões de parametros e 500 mil neurons treinada com mais de 1,3 milhão de imagens para a classificação de 1000 diferentes classes. A idéia, nesse caso, é remover a última camada da rede, treinada para a classificação das 1000 classes, e substituir por outra que será treinada com um novo dataset para um novo objetivo.\nRemover usando o index\nresnet18 = models.resnet18() cnn_modules = list(resnet18.children())[:-1] cnn = nn.Sequential(*cnn_modules) Remover definindo ponto de corte\nresnet18 = models.resnet18() cut = next(i for i,o in enumerate(resnet18.children()) if isinstance(o,nn.AdaptiveAvgPool2d)) m_cut = resnet18[:cut] cnn = nn.Sequential(m_cut, AdaptiveConcatPool2d()) ","date":"14 January 2020","permalink":"/posts/substituir-ultima-camada-rede-neural-pytorch/","section":"Posts","summary":"Durante o desenvolvimento de uma aplicação utilizando machine learning para, por exemplo, classificar imagens, não é necessário que se desenvolva uma Convolutional Neural Network do zero. Isso na verdade seria uma enorme perda de tempo e recursos computacionais, além de exigir do desenvolvedor expertise em tópicos como a inicialização dos pesos na rede neural.","title":"Como Substituir a Última Camada de Rede Neural no PyTorch"},{"content":"Emacs Key Biddings # C-x reserved for Emacs native essential keybindings: buffer, window, frame, file, directory, etc…\nC-c reserved for user and major mode:\nC-c letter reserved for user. \u0026lt;F5\u0026gt;-\u0026lt;F9\u0026gt; reserved for user. C-c C-letter reserved for major mode. Don\u0026rsquo;t rebind C-g, C-h and ESC.\nExamples:\nC-x C-f\tfind-file: first prompts for a filename and then loads that file into a editor buffer of the same name C-x C-s\tsave-buffer: saves the buffer into the associated filename C-x C-w\twrite-named-file: prompts for a new filename and writes the buffer into it C-x b switch-to-buffer: display a different buffer on the screen C-x o other-window: move the cursor to the other window C-x C-b\tlist-buffers: lists those buffers currently loaded into emacs C-g to cancel any action you have started. Doom Emacs Key Bindings # SPC h b b Abre lista de atalhos de teclado M-d Cria multiplos cursores SPC h v Able lista de variaveis evil-snipe navigation # f or t ; - next , - previous\navy navigation # g s SPC - Começa a busca no buffer pelo avy\nevil-lion # glip= # gl - left align operator, ip - text paragraph, = separator gLip, # gL - right align operator, \u0026lsquo;,\u0026rsquo; separator\nOrg Mode # Org Mode Key Bindings C-M-i (complete-symbol) complete word at point C-c \u0026rsquo; for editing the current code block.\nsetting tags # C-c C-q (org-set-tags-command) enter new tags for the current headline.\nhandling links # C-c C-l (org-insert-link) insert a link.\nproperty syntax # C-c C-x p (org-set-property) set a property. C-c C-c s (org-set-property) set a property in the current entry. C-c C-c d (org-delete-property) remove a property from the current entry.\nstructure editing # C-c C-x C-w (org-cut-subtree) kill subtree. C-c C-x M-w (org-copy-subtree) copy subtree to kill ring. C-c C-x C-y (org-paste-subtree) yank subtree from kill ring. C-c C-x c (org-clone-subtree-with-time-shift) Clone a subtree by making a number of sibling copies of it. C-c C-w (org-refile) Refile entry or region to a different location.\ndoom emacs links # doom emacs workflows emacs doom for newbies ox-hugo # C-c C-x p Set property SPC m o Set property C-c C-e H H Export C-c C-e H A Export all Exemplo all-posts Org Mode Code Snippets # Para adicionar um Code Snippet digite \u0026lt;s + TAB para autocompletar.\nPara que o print() funcione em códigos python, adicionar o argumento no header \u0026lsquo;:results output\u0026rsquo;.\nExemplo Closure Javascript # const counter = () =\u0026gt; { let n = 0; return { count: () =\u0026gt; n++, reset: () =\u0026gt; { n = 0; } }; } const c = counter(), d = counter(); // Create two counters console.log(c.count()) // =\u0026gt; 0 console.log(d.count()) // =\u0026gt; 0: they count independently console.log(c.reset()) // reset() and count() methods share state console.log(c.count()) // =\u0026gt; 0: because we reset c console.log(d.count()) // =\u0026gt; 1: d was not reset Exemplo Python # def hamming(a, b): return len([i for i in filter(lambda x: x[0] != x[1], zip(a, b))]) a = \u0026#34;Teste string 1\u0026#34; b = \u0026#34;Teste string 2\u0026#34; result = hamming(a, b) print(result) a = [1, 2, 3] b = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(list(zip(a, b))) ","date":"10 January 2020","permalink":"/posts/emacs-key-bindings/","section":"Posts","summary":"Emacs Key Biddings # C-x reserved for Emacs native essential keybindings: buffer, window, frame, file, directory, etc…\nC-c reserved for user and major mode:\nC-c letter reserved for user. \u0026lt;F5\u0026gt;-\u0026lt;F9\u0026gt; reserved for user.","title":"Emacs Key Bindings"},{"content":"Vim Command Language and examples of how to get things done.\nVerbs # v : visual c : change d : delete y : yank/copy Modifiers # i : inside a : around t : till..finds a character f : find..like till except including the char / : search..find a string/regex Text Objects # w : word s : sentence p : paragraph b : block/parentheses, t : tag, works for html/xml VIM Shortcuts # Navigation # zz : current line to top zt : current line to middle zb : current line to bottom C+y : scroll up one line C+e : scroll down one line C+u : scroll up half-page C+d : scroll down half-page C+b : scroll up full-page C+f : scroll down full-page H : cursor to the top of the screen M : cursor to the middle of the screen L : cursor to the botton of the screen e : go to the end of the current word. E : go to the end of the current WORD. b : go to the previous (before) word. B : go to the previous (before) WORD. w : go to the next word. W : go to the next WORD. g; : go to the last editing place. 0 : beginning of line ^ : first char of line $ : end of line { : Go to the beginning of the current paragraph. } : Go to the end of the current paragraph. /i : Search to the next occurrence of it. ?i : Search to the previous occurrence of it. – : Go to the next occurrence of the current word under the cursor. # : Go to the previous occurrence of the current word under the cursor. % : Go to the matching braces, or parenthesis inside code. Folding # zf#j : creates a fold from the cursor down # lines. zf/string : creates a fold from the cursor to string . za : opens/closes all folds zj : moves the cursor to the next fold zk : moves the cursor to the previous fold zc : closes a fold at the cursor zo : opens a fold at the cursor zO : opens all folds at the cursor zm : increases the foldlevel by one zM : closes all open folds zr : decreases the foldlevel by one zR : decreases the foldlevel to zero — all folds will be open zd : deletes the fold at the cursor zE : deletes all folds [z : move to start of open fold ]z : move to end of open fold Jump # C+o : go to origin Marks # m + letter : create mark \u0026#39; + letter : go to mark Yank / Paste # :reg : list registers \u0026#34;1p : paste previous deletes/yanks yiw : Yank inner word (copy word under cursor, say \u0026#34;first\u0026#34;). viwp : Select \u0026#34;second\u0026#34;, then replace it with \u0026#34;first\u0026#34;. yi( : equivalent to yib, yanks the contents inside parenthesis. yi{ : equivalent to yiB, yanks the contents inside braces. Insert Multiple # 80i/\u0026lt;ESC\u0026gt; : insert 80 \u0026#39;/\u0026#39; in a line 20Otest\u0026lt;ESC\u0026gt; : insert 20 lines of \u0026#39;test\u0026#39; Change Multiple # * : to select all words cgn+Esc : to change de word . : to change the next Esc : to enter \u0026#39;command mode\u0026#39; C-v : to enter visual block mode and select the columns of text. M-i : to enter insert mode and type the text you want to insert. Esc : wait 1 second and the inserted text will appear on every line. :%s/foo/bar/g :s/foo/bar/g :%s/foo/bar/gc Selection # ggVG : select all Letter Case # ~ : changes the case of current character guu : change current line from upper to lower. gUU : change current LINE from lower to upper. guw : change to end of current WORD from upper to lower. guaw : change all of current WORD to lower. gUw : change to end of current WORD from lower to upper. gUaw : change all of current WORD to upper. g~~ : invert case to entire line guG : change to lowercase until the end of document. Split # :sp : horizontal split :vs : vertical split C+W S : horizontal splitting C+W v : vertical splitting C+W q : close split C+W C+W : switch between windows C+W J K, H, L : switch to adjacent window ( up, down, left, right ) C-w t C-w K : change two vertically split windows to horizonally split C-w t C-w H : Horizontally to vertically C-w t : makes the first (topleft) window current C-w K : moves the current window to full-width at the very top C-w H : moves the current window to full-height at far left Tags # Spaces # :%le\t: Remove left spaces in the entire file Macros # qd : start recording to register d q : stop recording @d : execute your macro @@ : execute your macro again VIM Plugins # Prettier # L-p : Manually trigger Prettier FZF # C-t : tab split C-x : split C-v : vsplit Surround # cs\u0026#34;\u0026#39; : replace \u0026#34; with \u0026#39; cst\u0026#34; : replace tag with \u0026#34; ds\u0026#34; : to remove \u0026#34; delimiters entirely. ysiw] : add brackets arround a word. cs]{ : add some space (use } instead of { for no space): cs]{ yssb : wrap the entire line in parentheses with yssb or yss). Commenter # L-cc : Comment out the current line or text selected in visual mode. L-cn : Same as cc but forces nesting. L-c\u0026lt;space\u0026gt; : Toggles the comment state of the selected line(s). L-cm : Comments the given lines using only one set of multipart delimiters. L-ci : Toggles the comment state of the selected line(s) individually. L-cs : Comments out the selected lines with a pretty block formatted layout. L-cy : Same as cc except that the commented line(s) are yanked first. L-c$ : Comments the current line from the cursor to the end of line. L-cA : Adds comment delimiters to the end of line and goes into insert mode between them. L-ca : Switches to the alternative set of delimiters. L-cl : Delimiters are aligned down the left side (\u0026lt;leader\u0026gt;cl) or both sides (\u0026lt;leader\u0026gt;cb). L-cu : Uncomments the selected line(s). vim-easy-align # vipga= : visual-select inner paragraph, Start EasyAlign (ga), Align around = gaip= : Start EasyAlign for inner paragraph, Align around = = : Around the 1st occurrences 2= : Around the 2nd occurrences *= : Around all occurrences **= : Left/Right alternating alignment around all occurrences \u0026lt;Enter\u0026gt; : Switching between left/right/center alignment modes splitjoin.vim # gS : to split a one-liner into multiple lines gJ : to join a block into a single-line statement. ","date":"10 January 2020","permalink":"/posts/vim-key-bindings/","section":"Posts","summary":"Vim Command Language and examples of how to get things done.\nVerbs # v : visual c : change d : delete y : yank/copy Modifiers # i : inside a : around t : till.","title":"Vim Key Bindings"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub .\n","date":"28 February 2019","permalink":"/about/","section":"Marco Ribeiro","summary":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Para treinar um modelo de machine learning que realize o reconhecimento de caracteres, OCR, é necessário uma grande quantidade de imagens de placas. Daria um trabalho enorme conseguir milhares de imagens de carros com as placas visiveis, recortar as placas das imagens e anotar as imagens com os textos dos números das placas. Minha solução para obter essas milhares de imagens foi simplesmente gerá-las.\nComo o Brasil está adotando um novo padrão de placas é necessário utilizar dois templates. O primeiro utiliza imagens de placas antigas e insere os caracteres no padrão ABC-1234, o segundo com imagens de placas novas, insere os caracteres com a nova fonte no padrão ABC1D23 com 4 letras e 3 números.\nPara gerar os números de placas antigas foram utilizadas as seguintes funções:\nfrom random import randrange letters = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; letters_len = len(letters) def get_idx(l): return randrange(l) def plate_number_generator(): plate_number = \u0026#39;\u0026#39; for i in range(3): plate_number += letters[get_idx(letters_len)] plate_number += format(randrange(9999), \u0026#39;04d\u0026#39;) return plate_number def new_plate_number_generator(): plate_number = \u0026#39;\u0026#39; for i in range(3): plate_number += letters[get_idx(letters_len)] plate_number += format(randrange(9), \u0026#39;01d\u0026#39;) plate_number += letters[get_idx(letters_len)] plate_number += format(randrange(99), \u0026#39;02d\u0026#39;) return plate_number plate = plate_number_generator() new_plate = new_plate_number_generator() print(f\u0026#39;Placa antiga: {plate}\u0026#39;) print(f\u0026#39;Placa nova: {new_plate}\u0026#39;) Para gerar as imagens das placas\n","date":"1 January 0001","permalink":"/posts/gerador-imagens-placas-carros/","section":"Posts","summary":"Para treinar um modelo de machine learning que realize o reconhecimento de caracteres, OCR, é necessário uma grande quantidade de imagens de placas. Daria um trabalho enorme conseguir milhares de imagens de carros com as placas visiveis, recortar as placas das imagens e anotar as imagens com os textos dos números das placas.","title":"Criando Um Gerador de Imagens de Placas de Carros"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]